#include "Utils.h"
#include "PointCloudGenerator.hpp"

#include "DataLoader.hpp"
#include "GPUProgramLoader.hpp"

#include "SurfaceMeasurement.hpp"  // Step 1
#include "PoseEstimator.hpp"       // Step 2 (developing)
#include "SurfaceReconstructor.hpp"// Step 3
#include "SurfacePredictor.hpp"    // Step 4

int main() {
    // Make OpenCV silent
    cv::utils::logging::setLogLevel(cv::utils::logging::LOG_LEVEL_SILENT);

    // Some timers
    int surfaceMeasurementTimer(0);
    int poseEstimationTimer(0);
    int surfaceReconstructionTimer(0);
    int surfacePredictionTimer(0);

    // Camera intrisic of calibrated Kinect Camera
    Eigen::Matrix3f intrinsic = getIntrinsic();

    // Init the data folder
    DataLoader dataLoader(DATA_PATH);

    // Compile OpenCL kernels, and create contex and command queue
    GPUProgramLoader gpu = GPUProgramLoader();

    cl_command_queue openCLQueue = gpu.getQueue();
    cl_context openCLCtx = gpu.getContext();
    
    // CPU based ICP need PCL point cloud
    PointCloudGenerator pointCloudGenerator = PointCloudGenerator(intrinsic);

    // To be implemented in parallel?
    // PoseEstimator poseEstimator = PoseEstimator(openCLManager.getKernelByKey("DataAssociationKernel"), openCLQueue);

    // SurfacePredictor for executing RayCasting to TSDF
    SurfacePredictor surfacePredictor = SurfacePredictor(openCLCtx, gpu.getKernelByKey("RayCasterKernel"), openCLQueue);

    // Prepare RayCast Generate RGB Frame
    GPUBuffer rayCastLastRGBFrame = GPUBuffer(openCLCtx, openCLQueue, FRAME_WIDTH * FRAME_HEIGHT * 3);
    surfacePredictor.setColourMapBuffer(rayCastLastRGBFrame);
    // Prepare RayCast Generate Depth Frame
    GPUBuffer rayCastLastDepthFrame = GPUBuffer(openCLCtx, openCLQueue, FRAME_WIDTH * FRAME_HEIGHT);
    surfacePredictor.setDepthMapBuffer(rayCastLastDepthFrame);

    // Create some buffers saver for next frame
    BufferManager bufferManager = BufferManager(openCLCtx, openCLQueue);

    // TSDF SurfaceReconstructor
    // Responsible for tsdf Integration
    SurfaceReconstructor surfaceReconstructor = SurfaceReconstructor(openCLCtx, gpu.getKernelByKey("TSDFIntegrationKernel"), openCLQueue);

    // Set all buffers for SurfaceReconstructor
    GPUBuffer globalTSDFValuesVolume = GPUBuffer(openCLCtx, openCLQueue, VOLUME_RES * VOLUME_RES * VOLUME_RES, -1.0f);
    surfaceReconstructor.setValuesBuffer(globalTSDFValuesVolume);

    GPUBuffer globalTSDFWeightsVolume = GPUBuffer(openCLCtx, openCLQueue, VOLUME_RES * VOLUME_RES * VOLUME_RES, 0.f);
    surfaceReconstructor.setWeightsBuffer(globalTSDFWeightsVolume);

    GPUBuffer globalTSDFColoursVolume = GPUBuffer(openCLCtx, openCLQueue, VOLUME_RES * VOLUME_RES * VOLUME_RES * 3, 0.f);
    surfaceReconstructor.setColoursBuffer(globalTSDFColoursVolume);

    // SurfaceMeasurement for calculating VertexMap and NormalMap
    SurfaceMeasurement surfaceMeasurement =
        SurfaceMeasurement(gpu.getKernelByKey("VertexMapKernel"),
            gpu.getKernelByKey("NormalMapKernel"), openCLQueue);

    //CPU based ICP
    //pcl::PointCloud<pcl::PointXYZRGBA> rayCasterPointCloud, currPointCloud;

    // Pose = Identity as init
    Eigen::Matrix4f pose = Eigen::Matrix4f::Identity();

    // Start processing frame
    for (int i = 0; i < dataLoader.getDataSetSize(); i++) {

        // Last Frame generated By RayCasting
        //GPUBuffer lastDepth = openCLBufferManager.getBufferByKey("last_depth_frame");
        //GPUBuffer lastRGB = openCLBufferManager.getBufferByKey("last_rgb_frame");
        //GPUBuffer vertexMapForLast = GPUBuffer(openCLCtx, openCLQueue, FRAME_WIDTH * FRAME_HEIGHT * RGB_CHANNEL);
        //GPUBuffer normalMapForLast = GPUBuffer(openCLCtx, openCLQueue, FRAME_WIDTH * FRAME_HEIGHT * RGB_CHANNEL);

        //if (i != 0) {
        //   lastDepth.upload();
        //   lastRGB.upload();
        //   vertexNormalMapCalculator.calculateVertexMap(vertexMapForLast, lastDepth, intrinsic);
        //   vertexMapForLast.download();
        //   vertexNormalMapCalculator.calculateNormalMap(normalMapForLast, vertexMapForLast);
        //   normalMapForLast.download();
        //}

        std::cout << "MAIN >> Starting processing Frame #" << i << std::endl;
        // Get Frame pair
        Frame frame = dataLoader.getFrameByIndex(i);

        // Push the frame into GPUmemory for later calculation
        GPUBuffer depthFrame = GPUBuffer(openCLCtx, openCLQueue, frame.getDepthFrame());
        GPUBuffer rgbFrame = GPUBuffer(openCLCtx, openCLQueue, frame.getRGBFrame());
        std::cout << "MAIN >> RGB Frame and Depth Frame " << frame.id << " loaded." << std::endl;

        // Prepare container for saving result
        GPUBuffer vertexMap = GPUBuffer(openCLCtx, openCLQueue, 3 * FRAME_WIDTH * FRAME_HEIGHT);
        GPUBuffer normalMap = GPUBuffer(openCLCtx, openCLQueue, 3 * FRAME_WIDTH * FRAME_HEIGHT);
        auto t1 = std::chrono::high_resolution_clock::now();
        // Calculate VertexMap and NormalMap on GPU
        surfaceMeasurement.calculateVertexMap(depthFrame, intrinsic, vertexMap);
        //std::cout << "MAIN >> VertexMap calculated for current frame. " << std::endl;
        surfaceMeasurement.calculateNormalMap(vertexMap, normalMap);
        //std::cout << "MAIN >> NormalMap calculated for current frame. " << std::endl;
        auto t2 = std::chrono::high_resolution_clock::now();
        surfaceMeasurementTimer += std::chrono::duration_cast<std::chrono::microseconds>(t2 - t1).count();
        if (i != 0) {
            // Do ICP
            
            // CPU based GICP Color
            //currPointCloud = pointCloudGenerator.processFrame(vertexMap, rgbFrame);
            //rayCasterPointCloud = pointCloudGenerator.processFrame(vertexMapForLast, lastRGB);
            //pose = icpExecuter.computeOnCPU(rayCasterPointCloud.makeShared(), currPointCloud.makeShared()).first;

            // For now just read groundtruth pose from assoc.txt
            auto t3 = std::chrono::high_resolution_clock::now();
            pose = makeTranslation() * (dataLoader.getFrameByIndex(0).pose.inverse() * frame.pose);
            auto t4 = std::chrono::high_resolution_clock::now();
            //std::cout << "MAIN >> New Pose Calculated. \n" << pose << std::endl;
            poseEstimationTimer += std::chrono::duration_cast<std::chrono::microseconds>(t4 - t3).count();
        } else {
            pose = Eigen::Matrix4f::Identity();
        }

        // Integrate the current frame into global TSDF
        auto t5 = std::chrono::high_resolution_clock::now();
        surfaceReconstructor.executeIntegration(depthFrame, rgbFrame, pose.inverse());
        //surfaceReconstructor.getResultToHost();
        auto t6 = std::chrono::high_resolution_clock::now();
        surfaceReconstructionTimer += std::chrono::duration_cast<std::chrono::microseconds>(t6 - t5).count();
        //std::cout << "MAIN >> Integrated to TSDF. " << pose << std::endl;
        // Get the intermiedate result, if needed
        //

        // Raycast to get Frame back
        auto t7 = std::chrono::high_resolution_clock::now();
        surfacePredictor.raycast(globalTSDFValuesVolume, globalTSDFColoursVolume, pose);
        auto t8 = std::chrono::high_resolution_clock::now();
        surfacePredictionTimer += std::chrono::duration_cast<std::chrono::microseconds>(t8 - t7).count();
        //std::cout << "MAIN >> RayCast to get Depth and Colour Frame. " << pose << std::endl;

        // Cleaning for avoiding Memory Leakage
        depthFrame.clear();
        rgbFrame.clear();

        vertexMap.clear();
        normalMap.clear();
        std::cout << "MAIN >> Frame #" << i << " successfully procesed." << std::endl;
    }
    // Last Result Peeking
    surfacePredictor.raycast(globalTSDFValuesVolume, globalTSDFColoursVolume, makeTranslation() * Eigen::Matrix4f::Identity());
    surfacePredictor.showRayCastFrame();

    GPUBuffer lastVertexMap = GPUBuffer(openCLCtx, openCLQueue, 3 * FRAME_WIDTH * FRAME_HEIGHT);
    GPUBuffer lastNormalMap = GPUBuffer(openCLCtx, openCLQueue, 3 * FRAME_WIDTH * FRAME_HEIGHT);

    surfaceMeasurement.calculateVertexMap(rayCastLastDepthFrame, intrinsic, lastVertexMap);
    surfaceMeasurement.calculateNormalMap(lastVertexMap, lastNormalMap);
    lastVertexMap.clear();
    lastNormalMap.clear();

    // Timer output
    std::cout << "SurfaceMeasurement Timer: " << surfaceMeasurementTimer  << std::endl;
    std::cout << "PoseEstimation Timer: " << poseEstimationTimer<< std::endl;
    std::cout << "SurfaceReconstruction Timer: " << surfaceReconstructionTimer  << std::endl;
    std::cout << "SurfacePredictor Timer: " << surfacePredictionTimer << std::endl;
}